
AVRASM ver. 2.2.7  C:\Users\Huang Wei\Documents\Atmel Studio\7.0\Wei_Huang_Lab8_sourcecode\Wei_Huang_Lab8_sourcecode\Wei_Huang_Lab8_sourcecode.asm Wed Dec 02 01:47:45 2020

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
C:\Users\Huang Wei\Documents\Atmel Studio\7.0\Wei_Huang_Lab8_sourcecode\Wei_Huang_Lab8_sourcecode\Wei_Huang_Lab8_sourcecode.asm(15): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
C:\Users\Huang Wei\Documents\Atmel Studio\7.0\Wei_Huang_Lab8_sourcecode\Wei_Huang_Lab8_sourcecode\Wei_Huang_Lab8_sourcecode.asm(15): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m128def.inc'
                                 
                                 ;***********************************************************
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;*
                                 ;*	Wei_Huang_Lab8_sourcecode.asm
                                 ;*
                                 ;*	square root caculate
                                 ;*
                                 ;*	This is the skeleton file for Lab 8 of ECE 375
                                 ;*
                                 ;***********************************************************
                                 ;*
                                 ;*	 Author: Wei Huang
                                 ;*	   Date: 11/24/2020 11:39:43 PM
                                 ;*
                                 ;***********************************************************
                                 .include "m128def.inc"			; Include definition file
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 ;***********************************************************
                                 ;*	Internal Register Definitions and Constants
                                 ;*	(feel free to edit these or add others)
                                 ;***********************************************************
                                 .def	rlo = r0				; Low byte of MUL result
                                 .def	rhi = r1				; High byte of MUL result
                                 .def	zero = r2				; Zero register, set to zero in INIT, useful for calculations
                                 .def	A = r3					; A variable
                                 .def	B = r4					; Another variable
                                 .def	C = r5					; Another variable
                                 .def	D = r6					;Another variable
                                 .def	E = r7					;Another variable
                                 .def	F = r8					;Another variable
                                 .def	mpr = r16				; Multipurpose register 
                                 .def	oloop = r17				; Outer Loop Counter
                                 .def	iloop = r18				; Inner Loop Counter
                                 .def	dataptr = r19			; data ptr
                                 .def	mpr0 = r20				;Multipurpose register 
                                 .def	best = r21				; best register
                                 .def	root_low = r22			;root _low register
                                 .def	root_high = r23			;root_high high register
                                 .def	counter_low = r24		;counter_low 			
                                 .def	counter_high = r25		;counter_high
                                 ;***********************************************************
                                 ;*	Data segment variables
                                 ;*	(feel free to edit these or add others)
                                 ;***********************************************************
                                 .dseg
                                 .org	$0100						; data memory allocation for operands
000100                           operand1:		.byte 2				; allocate 2 bytes for a variable named operand1
000102                           operand2:		.byte 2				; allocate 2 bytes for a variable named operand2
                                 		
000104                           operand3:		.byte 2				; allocate 2 bytes for a variable named operand3
000106                           operand4:		.byte 2				; allocate 2 bytes for a variable named operand4
                                 		
000108                           operand5:		.byte 2				; allocate 2 bytes for a variable named operand3
00010a                           operand6:		.byte 2				; allocate 2 bytes for a variable named operand4
                                 		
                                 .org $0116		
000116                           MUL_RESULT1:	.byte 3				;allocate 3 bytes for a variabke named MUL_RESULTX1
000119                           MUL_RESULT2:	.byte 3				;allocate 3 bytes for a variabke named MUL_RESULTY2
                                 		
00011c                           MUL_RESULT3:	.byte 3				;allocate 3 bytes for a variabke named MUL_RESULTX3
00011f                           MUL_RESULT4:	.byte 3				;allocate 3 bytes for a variabke named MUL_RESULTY4
                                 		
000122                           MUL_RESULT5:	.byte 3				;allocate 3 bytes for a variabke named MUL_RESULTX5
000125                           MUL_RESULT6:	.byte 3				;allocate 3 bytes for a variabke named MUL_RESULTY6
                                 
                                 .org $012C
00012c                           ADD_RESULT1:	.byte 3				;allocate 3 bytes for a variabke named ADD_RESULT1
00012f                           ADD_RESULT2:	.byte 3				;allocate 3 bytes for a variabke named ADD_RESULT2
000132                           ADD_RESULT3:	.byte 3				;allocate 3 bytes for a variabke named ADD_RESULT3
                                 
                                 .org $0142	
000142                           ROOT_RESULT1:	.byte 2				;allocate 3 bytes for a variabke named ROOT_RESULT1
000144                           ROOT_RESULT2:	.byte 2				;allocate 3 bytes for a variabke named ROOT_RESULT2
000146                           ROOT_RESULT3:	.byte 2				;allocate 3 bytes for a variabke named ROOT_RESULT3
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Start of Code Segment
                                 ;***********************************************************
                                 .cseg							; Beginning of code segment
                                 ;-----------------------------------------------------------
                                 ; Interrupt Vectors
                                 ;-----------------------------------------------------------
                                 .org	$0000					; Beginning of IVs
000000 c045                      		rjmp 	INIT			; Reset interrupt
                                 .org	$0046					; End of Interrupt Vectors
                                 ;-----------------------------------------------------------
                                 ; Program Initialization
                                 ;-----------------------------------------------------------
                                 INIT:	; The initialization routine
000046 2422                      		clr		zero
000047 2755                      		clr		best
                                 
                                 ; To do
                                 ; your code goes here
                                 ;initial stack pointer
000048 ef0f                      		ldi mpr, low(RAMEND)	;load low bits of RAMEND into mpr
000049 bf0d                      		out SPL, mpr			;output mpr into stack pointer low
00004a e100                      		ldi mpr, high(RAMEND)	;load high bits of RAMEND into mpr
00004b bf0e                      		out SPH, mpr			;output mpr into stack pointer high
                                 		
                                 		;first number
00004c e5e0                      		ldi ZL, low(TreasureInfo <<1)	;loade low byte address into Z
00004d e0f7                      		ldi ZH, high(TreasureInfo <<1)	;loade high byte address into Z
00004e e0c0                      		ldi YL, low(operand1)			;load low byte address into Y
00004f e0d1                      		ldi YH, high(operand1)			;load high byte address into Y
000050 9105                      		lpm mpr, Z+						;load memory program by Z low
000051 9144                      		lpm mpr0, Z						;load memory program by Z
000052 0f44                      		lsl mpr0						;shift left 0
000053 1f00                      		rol mpr							;rotate left 0
000054 1f55                      		rol best						;rotate left to best 0
000055 0f44                      		lsl mpr0						;shift letf 1
000056 1f00                      		rol mpr							;rotate left 1
000057 1f55                      		rol best						;rotate left 0
000058 9309                      		st Y+, mpr						;store mpr to YL
000059 8358                      		st Y, best						;store best register to Y	
                                 		;first number end
                                 		
                                 		;second number
00005a e0c2                      		ldi YL, low(operand2)			;load low byte adress into Y
00005b e0d1                      		ldi YH, high(operand2)			;load high byte address into Y
00005c 9105                      		lpm mpr, Z+						;load memory program by Z low
00005d 9144                      		lpm mpr0, Z						;load memory program by Z
00005e 0f44                      		lsl mpr0						;left shift 1
00005f 1f00                      		rol mpr							;rotate left 1
000060 1f55                      		rol best						;rotate left 1 to best
000061 2d52                      		mov best, zero					;move to zero
000062 0f44                      		lsl	mpr0						;left shift 0
000063 1f00                      		rol mpr							;rotate left 0 
000064 1f55                      		rol best						;rotate left 0 to best
000065 2d52                      		mov best, zero					;move to zero
000066 0f44                      		lsl mpr0						;left shitf 0
000067 1f00                      		rol mpr							;rotate left 0
000068 1f55                      		rol best						;rortate left 0
000069 0f44                      		lsl mpr0						;left shift 1
00006a 1f00                      		rol mpr							;rotate left 1
00006b 1f55                      		rol best						;rotate left 1
00006c 9309                      		st Y+, mpr						;store mpr to Y low
00006d 8358                      		st Y, best						;store best to Y
                                 		;scond number end
                                 		
                                 		;third number
00006e e0c4                      		ldi YL, low(operand3)			;load low byte adress into Y
00006f e0d1                      		ldi YH, high(operand3)			;load high byte address into Y
000070 9105                      		lpm mpr, Z+						;load memory program by Z low
000071 9144                      		lpm mpr0, Z						;load memory program by Z
000072 0f44                      		lsl mpr0						;left shift 1
000073 1f00                      		rol mpr							;rotate left 1
000074 1f55                      		rol best						;rotate left 1 to best
000075 2d52                      		mov best, zero					;move to zero
000076 0f44                      		lsl mpr0						;left shift 0
000077 1f00                      		rol mpr							;rotate left 0
000078 1f55                      		rol best						;rotate left 0 to best
000079 2d52                      		mov best, zero					;move to zero
00007a 0f44                      		lsl mpr0						;left shift 0
00007b 1f00                      		rol mpr							;rotate left 0
00007c 1f55                      		rol best						;rotate left 0 to best
00007d 2d52                      		mov best, zero					;move to zero
00007e 0f44                      		lsl mpr0						;left shift 0
00007f 1f00                      		rol mpr							;rotate left 0
000080 1f55                      		rol best						;rotate left 0 to best
000081 2d52                      		mov best, zero					;move to zero
000082 0f44                      		lsl mpr0						;left shift 0
000083 1f00                      		rol mpr							;rotate left 0
000084 1f55                      		rol best						;rotate left 0 to best
000085 0f44                      		lsl mpr0						;left shift 0
000086 1f00                      		rol mpr							;rotate left 0
000087 1f55                      		rol best						;rotate left 0 to best
000088 9309                      		st Y+, mpr						;store mpr to Y low
000089 8358                      		st Y, best						;store best to Y
                                 		;third number end
                                 		
                                 		;fourth number
00008a e0c6                      		ldi YL, low(operand4)			;load low byte adress into Y
00008b e0d1                      		ldi YH, high(operand4)			;load high byte address into Y
00008c 9105                      		lpm mpr, Z+						;load memory program by Z low
00008d 9144                      		lpm mpr0, Z						;load memory program by Z
00008e 0f44                      		lsl mpr0						;left shift 0
00008f 1f00                      		rol mpr							;rotate left 0
000090 1f55                      		rol best						;rotate left 0 to best
000091 2d52                      		mov best, zero					;move to zero
000092 0f44                      		lsl mpr0						;left shift 0
000093 1f00                      		rol mpr							;rotate left 0
000094 1f55                      		rol best						;rotate left 0 to best
000095 2d52                      		mov best, zero					;move to zero
000096 0f44                      		lsl mpr0						;left shift 0
000097 1f00                      		rol mpr							;rotate left 0
000098 1f55                      		rol best						;rotate left 0 to best
000099 2d52                      		mov best, zero					;move to zero
00009a 0f44                      		lsl mpr0						;left shift 0
00009b 1f00                      		rol mpr							;rotate left 0
00009c 1f55                      		rol best						;rotate left 0 to best
00009d 2d52                      		mov best, zero					;move to zero
00009e 0f44                      		lsl mpr0						;left shift 0
00009f 1f00                      		rol mpr							;rotate left 0
0000a0 1f55                      		rol best						;rotate left 0 to best
0000a1 2d52                      		mov best, zero					;move to zero
0000a2 0f44                      		lsl mpr0						;left shift 0
0000a3 1f00                      		rol mpr							;rotate left 0
0000a4 1f55                      		rol best						;rotate left 0 to best
0000a5 2d52                      		mov best, zero					;move to zero
0000a6 0f44                      		lsl mpr0						;left shift 1
0000a7 1f00                      		rol mpr							;rotate left 1
0000a8 1f55                      		rol best						;rotate left 1 to best
0000a9 0f44                      		lsl mpr0						;left shift 0
0000aa 1f00                      		rol mpr							;rotate left 0
0000ab 1f55                      		rol best						;rotate left 0 to best
0000ac 9309                      		st Y+, mpr						;store mpr to Y low
0000ad 8358                      		st Y, best						;store best to Y
                                 		;fourth numbe end
                                 		
                                 		;fifth number
0000ae e0c8                      		ldi YL, low(operand5)			;load low byte adress into Y
0000af e0d1                      		ldi YH, high(operand5)			;load high byte address into Y
0000b0 9105                      		lpm mpr, Z+						;load memory program by Z low
0000b1 9105                      		lpm mpr, Z+
0000b2 9309                      		st Y+, mpr						;store mpr to Y low
                                 		;fifth number end
                                 	
                                 		;sixth number
0000b3 e0ca                      		ldi YL, low(operand6)			;load low byte adress into Y
0000b4 e0d1                      		ldi YH, high(operand6)			;load high byte address into Y
0000b5 9105                      		lpm mpr, Z+						;load memory program by Z low
0000b6 9144                      		lpm mpr0, Z						;load memory program by Z
0000b7 0f44                      		lsl mpr0						;left shift 1
0000b8 1f00                      		rol mpr							;rotate left 1
0000b9 1f55                      		rol best						;rotate left 1 to best
0000ba 2d52                      		mov best, zero					;move to zero
0000bb 0f44                      		lsl mpr0						;left shift 1
0000bc 1f00                      		rol mpr							;rotate left 1
0000bd 1f55                      		rol best						;rotate left 1 to best
0000be 2d52                      		mov best, zero					;move to zero
0000bf 0f44                      		lsl mpr0						;left shift 1
0000c0 1f00                      		rol mpr							;rotate left 1
0000c1 1f55                      		rol best						;rotate left  0 to best
0000c2 0f44                      		lsl mpr0						;left shift 1
0000c3 1f00                      		rol mpr							;rotate left 1
0000c4 1f55                      		rol best						;rotate left 1 to best
0000c5 9309                      		st Y+, mpr						;store mpr to Y low
0000c6 8358                      		st Y, best						;store best to Y
                                 		;sixth number end
                                 ;-----------------------------------------------------------
                                 ; MAIN PROGRAM
                                 ;-----------------------------------------------------------
                                 MAIN:
                                 		;MUL16
                                 		;operand1^2
0000c7 d00f                      		rcall	MUL1
                                 		;operand2^2
0000c8 d045                      		rcall	MUL2
                                 		;operand3^2
0000c9 d07b                      		rcall	MUL3
                                 		;operand4^2
0000ca d0b1                      		rcall	MUL4
                                 		;operand5^2
0000cb d0e7                      		rcall	MUL5
                                 		;operand6^2
0000cc d11d                      		rcall	MUL6
                                 
                                 		;ADD32
                                 		;ADD MUL_RESULT1 and MUL_RESULT2
0000cd d153                      		rcall	ADD1
                                 		;ADD MUL_RESULT3 and MUL_RESULT4
0000ce d168                      		rcall	ADD2
                                 		;ADD MUL_RESULT5 and MUL_RESULT6
0000cf d17d                      		rcall	ADD3
                                 
                                 		;Root40
                                 		;ROOT square ADD_RESULT1
0000d0 d192                      		rcall ROOT1
                                 		;ROOT square ADD_RESULT2
0000d1 d1ce                      		rcall ROOT2
                                 		;ROOT square ADD_RESULT3
0000d2 d20a                      		rcall ROOT3
                                 
                                 		;BEST CHOICE
0000d3 d246                      		rcall CHOICE
                                 
                                 		;AVERAGE Distance
0000d4 d28a                      		rcall DISTANCE
                                 		
                                 	
                                 
0000d5 940c 03a6                  		jmp	Grading
                                 
                                 ;***********************************************************
                                 ;*	Procedures and Subroutines
                                 ;***********************************************************
                                 ; your code can go here as well
                                 ;***********************************************************
                                 ;*	Function: MUL1
                                 ;*  Describtion: cactulate operand1^2
                                 ;*	reference: lab5 MUL16 fucntion
                                 ;***********************************************************
                                 MUL1:
0000d7 923f                      		push 	A				; Save A register
0000d8 924f                      		push	B				; Save B register
0000d9 921f                      		push	rhi				; Save rhi register
0000da 920f                      		push	rlo				; Save rlo register
0000db 922f                      		push	zero			; Save zero register
0000dc 93bf                      		push	XH				; Save X-ptr
0000dd 93af                      		push	XL
0000de 93df                      		push	YH				; Save Y-ptr
0000df 93cf                      		push	YL				
0000e0 93ff                      		push	ZH				; Save Z-ptr
0000e1 93ef                      		push	ZL
0000e2 931f                      		push	oloop			; Save counters
0000e3 932f                      		push	iloop				
                                 
0000e4 2422                      		clr		zero			; Maintain zero semantics
                                 
                                 		; Set Y to beginning address of B
0000e5 e0c0                      		ldi		YL, low(operand1)	; Load low byte
0000e6 e0d1                      		ldi		YH, high(operand1)	; Load high byte
                                 
                                 		; Set Z to begginning address of resulting Product
0000e7 e1e6                      		ldi		ZL, low(MUL_RESULT1)	; Load low byte
0000e8 e0f1                      		ldi		ZH, high(MUL_RESULT1); Load high byte
                                 
                                 		; Begin outer for loop
0000e9 e012                      		ldi		oloop, 2		; Load counter
                                 MUL1_OLOOP:
                                 		; Set X to beginning address of A
0000ea e0a0                      		ldi		XL, low(operand1)	; Load low byte
0000eb e0b1                      		ldi		XH, high(operand1)	; Load high byte
                                 
                                 		; Begin inner for loop
0000ec e022                      		ldi		iloop, 2		; Load counter
                                 MUL1_ILOOP:
0000ed 903d                      		ld		A, X+			; Get byte of A operand
0000ee 8048                      		ld		B, Y			; Get byte of B operand
0000ef 9c34                      		mul		A,B				; Multiply A and B
0000f0 9031                      		ld		A, Z+			; Get a result byte from memory
0000f1 9041                      		ld		B, Z+			; Get the next result byte from memory
0000f2 0c03                      		add		rlo, A			; rlo <= rlo + A
0000f3 1c14                      		adc		rhi, B			; rhi <= rhi + B + carry
0000f4 8030                      		ld		A, Z			; Get a third byte from the result
0000f5 1c32                      		adc		A, zero			; Add carry to A
0000f6 8230                      		st		Z, A			; Store third byte to memory
0000f7 9212                      		st		-Z, rhi			; Store second byte to memory
0000f8 9202                      		st		-Z, rlo			; Store first byte to memory
0000f9 9631                      		adiw	ZH:ZL, 1		; Z <= Z + 1			
0000fa 952a                      		dec		iloop			; Decrement counter
0000fb f789                      		brne	MUL1_ILOOP		; Loop if iLoop != 0
                                 		; End inner for loop
                                 
0000fc 9731                      		sbiw	ZH:ZL, 1		; Z <= Z - 1
0000fd 9621                      		adiw	YH:YL, 1		; Y <= Y + 1
0000fe 951a                      		dec		oloop			; Decrement counter
0000ff f751                      		brne	MUL1_OLOOP		; Loop if oLoop != 0
                                 		; End outer for loop
                                 		 		
000100 912f                      		pop		iloop			; Restore all registers in reverves order
000101 911f                      		pop		oloop
000102 91ef                      		pop		ZL				
000103 91ff                      		pop		ZH
000104 91cf                      		pop		YL
000105 91df                      		pop		YH
000106 91af                      		pop		XL
000107 91bf                      		pop		XH
000108 902f                      		pop		zero
000109 900f                      		pop		rlo
00010a 901f                      		pop		rhi
00010b 904f                      		pop		B
00010c 903f                      		pop		A
00010d 9508                      		ret						; End a function with RET
                                 
                                 ;***********************************************************
                                 ;*	Function: MUL2
                                 ;*  Describtion: cactulate operand2^2
                                 ;*	reference: lab5 MUL16 fucntion
                                 ;***********************************************************
                                 MUL2:
00010e 923f                      		push 	A				; Save A register
00010f 924f                      		push	B				; Save B register
000110 921f                      		push	rhi				; Save rhi register
000111 920f                      		push	rlo				; Save rlo register
000112 922f                      		push	zero			; Save zero register
000113 93bf                      		push	XH				; Save X-ptr
000114 93af                      		push	XL
000115 93df                      		push	YH				; Save Y-ptr
000116 93cf                      		push	YL				
000117 93ff                      		push	ZH				; Save Z-ptr
000118 93ef                      		push	ZL
000119 931f                      		push	oloop			; Save counters
00011a 932f                      		push	iloop				
                                 
00011b 2422                      		clr		zero			; Maintain zero semantics
                                 
                                 		; Set Y to beginning address of B
00011c e0c2                      		ldi		YL, low(operand2)	; Load low byte
00011d e0d1                      		ldi		YH, high(operand2)	; Load high byte
                                 
                                 		; Set Z to begginning address of resulting Product
00011e e1e9                      		ldi		ZL, low(MUL_RESULT2)	; Load low byte
00011f e0f1                      		ldi		ZH, high(MUL_RESULT2); Load high byte
                                 
                                 		; Begin outer for loop
000120 e012                      		ldi		oloop, 2		; Load counter
                                 MUL2_OLOOP:
                                 		; Set X to beginning address of A
000121 e0a2                      		ldi		XL, low(operand2)	; Load low byte
000122 e0b1                      		ldi		XH, high(operand2)	; Load high byte
                                 
                                 		; Begin inner for loop
000123 e022                      		ldi		iloop, 2		; Load counter
                                 MUL2_ILOOP:
000124 903d                      		ld		A, X+			; Get byte of A operand
000125 8048                      		ld		B, Y			; Get byte of B operand
000126 9c34                      		mul		A,B				; Multiply A and B
000127 9031                      		ld		A, Z+			; Get a result byte from memory
000128 9041                      		ld		B, Z+			; Get the next result byte from memory
000129 0c03                      		add		rlo, A			; rlo <= rlo + A
00012a 1c14                      		adc		rhi, B			; rhi <= rhi + B + carry
00012b 8030                      		ld		A, Z			; Get a third byte from the result
00012c 1c32                      		adc		A, zero			; Add carry to A
00012d 8230                      		st		Z, A			; Store third byte to memory
00012e 9212                      		st		-Z, rhi			; Store second byte to memory
00012f 9202                      		st		-Z, rlo			; Store first byte to memory
000130 9631                      		adiw	ZH:ZL, 1		; Z <= Z + 1			
000131 952a                      		dec		iloop			; Decrement counter
000132 f789                      		brne	MUL2_ILOOP		; Loop if iLoop != 0
                                 		; End inner for loop
                                 
000133 9731                      		sbiw	ZH:ZL, 1		; Z <= Z - 1
000134 9621                      		adiw	YH:YL, 1		; Y <= Y + 1
000135 951a                      		dec		oloop			; Decrement counter
000136 f751                      		brne	MUL2_OLOOP		; Loop if oLoop != 0
                                 		; End outer for loop
                                 		 		
000137 912f                      		pop		iloop			; Restore all registers in reverves order
000138 911f                      		pop		oloop
000139 91ef                      		pop		ZL				
00013a 91ff                      		pop		ZH
00013b 91cf                      		pop		YL
00013c 91df                      		pop		YH
00013d 91af                      		pop		XL
00013e 91bf                      		pop		XH
00013f 902f                      		pop		zero
000140 900f                      		pop		rlo
000141 901f                      		pop		rhi
000142 904f                      		pop		B
000143 903f                      		pop		A
000144 9508                      		ret						; End a function with RET
                                 
                                 ;***********************************************************
                                 ;*	Function: MUL3
                                 ;*  Describtion: cactulate operand3^2
                                 ;*	reference: lab5 MUL16 fucntion
                                 ;***********************************************************
                                 MUL3:
000145 923f                      		push 	A				; Save A register
000146 924f                      		push	B				; Save B register
000147 921f                      		push	rhi				; Save rhi register
000148 920f                      		push	rlo				; Save rlo register
000149 922f                      		push	zero			; Save zero register
00014a 93bf                      		push	XH				; Save X-ptr
00014b 93af                      		push	XL
00014c 93df                      		push	YH				; Save Y-ptr
00014d 93cf                      		push	YL				
00014e 93ff                      		push	ZH				; Save Z-ptr
00014f 93ef                      		push	ZL
000150 931f                      		push	oloop			; Save counters
000151 932f                      		push	iloop				
                                 
000152 2422                      		clr		zero			; Maintain zero semantics
                                 
                                 		; Set Y to beginning address of B
000153 e0c4                      		ldi		YL, low(operand3)	; Load low byte
000154 e0d1                      		ldi		YH, high(operand3)	; Load high byte
                                 
                                 		; Set Z to begginning address of resulting Product
000155 e1ec                      		ldi		ZL, low(MUL_RESULT3)	; Load low byte
000156 e0f1                      		ldi		ZH, high(MUL_RESULT3); Load high byte
                                 
                                 		; Begin outer for loop
000157 e012                      		ldi		oloop, 2		; Load counter
                                 MUL3_OLOOP:
                                 		; Set X to beginning address of A
000158 e0a4                      		ldi		XL, low(operand3)	; Load low byte
000159 e0b1                      		ldi		XH, high(operand3)	; Load high byte
                                 
                                 		; Begin inner for loop
00015a e022                      		ldi		iloop, 2		; Load counter
                                 MUL3_ILOOP:
00015b 903d                      		ld		A, X+			; Get byte of A operand
00015c 8048                      		ld		B, Y			; Get byte of B operand
00015d 9c34                      		mul		A,B				; Multiply A and B
00015e 9031                      		ld		A, Z+			; Get a result byte from memory
00015f 9041                      		ld		B, Z+			; Get the next result byte from memory
000160 0c03                      		add		rlo, A			; rlo <= rlo + A
000161 1c14                      		adc		rhi, B			; rhi <= rhi + B + carry
000162 8030                      		ld		A, Z			; Get a third byte from the result
000163 1c32                      		adc		A, zero			; Add carry to A
000164 8230                      		st		Z, A			; Store third byte to memory
000165 9212                      		st		-Z, rhi			; Store second byte to memory
000166 9202                      		st		-Z, rlo			; Store first byte to memory
000167 9631                      		adiw	ZH:ZL, 1		; Z <= Z + 1			
000168 952a                      		dec		iloop			; Decrement counter
000169 f789                      		brne	MUL3_ILOOP		; Loop if iLoop != 0
                                 		; End inner for loop
                                 
00016a 9731                      		sbiw	ZH:ZL, 1		; Z <= Z - 1
00016b 9621                      		adiw	YH:YL, 1		; Y <= Y + 1
00016c 951a                      		dec		oloop			; Decrement counter
00016d f751                      		brne	MUL3_OLOOP		; Loop if oLoop != 0
                                 		; End outer for loop
                                 		 		
00016e 912f                      		pop		iloop			; Restore all registers in reverves order
00016f 911f                      		pop		oloop
000170 91ef                      		pop		ZL				
000171 91ff                      		pop		ZH
000172 91cf                      		pop		YL
000173 91df                      		pop		YH
000174 91af                      		pop		XL
000175 91bf                      		pop		XH
000176 902f                      		pop		zero
000177 900f                      		pop		rlo
000178 901f                      		pop		rhi
000179 904f                      		pop		B
00017a 903f                      		pop		A
00017b 9508                      		ret						; End a function with RET
                                 
                                 ;***********************************************************
                                 ;*	Function: MUL4
                                 ;*  Describtion: cactulate operand4^2
                                 ;*	reference: lab5 MUL16 fucntion
                                 ;***********************************************************
                                 MUL4:
00017c 923f                      		push 	A				; Save A register
00017d 924f                      		push	B				; Save B register
00017e 921f                      		push	rhi				; Save rhi register
00017f 920f                      		push	rlo				; Save rlo register
000180 922f                      		push	zero			; Save zero register
000181 93bf                      		push	XH				; Save X-ptr
000182 93af                      		push	XL
000183 93df                      		push	YH				; Save Y-ptr
000184 93cf                      		push	YL				
000185 93ff                      		push	ZH				; Save Z-ptr
000186 93ef                      		push	ZL
000187 931f                      		push	oloop			; Save counters
000188 932f                      		push	iloop				
                                 
000189 2422                      		clr		zero			; Maintain zero semantics
                                 
                                 		; Set Y to beginning address of B
00018a e0c6                      		ldi		YL, low(operand4)	; Load low byte
00018b e0d1                      		ldi		YH, high(operand4)	; Load high byte
                                 
                                 		; Set Z to begginning address of resulting Product
00018c e1ef                      		ldi		ZL, low(MUL_RESULT4)	; Load low byte
00018d e0f1                      		ldi		ZH, high(MUL_RESULT4); Load high byte
                                 
                                 		; Begin outer for loop
00018e e012                      		ldi		oloop, 2		; Load counter
                                 MUL4_OLOOP:
                                 		; Set X to beginning address of A
00018f e0a6                      		ldi		XL, low(operand4)	; Load low byte
000190 e0b1                      		ldi		XH, high(operand4)	; Load high byte
                                 
                                 		; Begin inner for loop
000191 e022                      		ldi		iloop, 2		; Load counter
                                 MUL4_ILOOP:
000192 903d                      		ld		A, X+			; Get byte of A operand
000193 8048                      		ld		B, Y			; Get byte of B operand
000194 9c34                      		mul		A,B				; Multiply A and B
000195 9031                      		ld		A, Z+			; Get a result byte from memory
000196 9041                      		ld		B, Z+			; Get the next result byte from memory
000197 0c03                      		add		rlo, A			; rlo <= rlo + A
000198 1c14                      		adc		rhi, B			; rhi <= rhi + B + carry
000199 8030                      		ld		A, Z			; Get a third byte from the result
00019a 1c32                      		adc		A, zero			; Add carry to A
00019b 8230                      		st		Z, A			; Store third byte to memory
00019c 9212                      		st		-Z, rhi			; Store second byte to memory
00019d 9202                      		st		-Z, rlo			; Store first byte to memory
00019e 9631                      		adiw	ZH:ZL, 1		; Z <= Z + 1			
00019f 952a                      		dec		iloop			; Decrement counter
0001a0 f789                      		brne	MUL4_ILOOP		; Loop if iLoop != 0
                                 		; End inner for loop
                                 
0001a1 9731                      		sbiw	ZH:ZL, 1		; Z <= Z - 1
0001a2 9621                      		adiw	YH:YL, 1		; Y <= Y + 1
0001a3 951a                      		dec		oloop			; Decrement counter
0001a4 f751                      		brne	MUL4_OLOOP		; Loop if oLoop != 0
                                 		; End outer for loop
                                 		 		
0001a5 912f                      		pop		iloop			; Restore all registers in reverves order
0001a6 911f                      		pop		oloop
0001a7 91ef                      		pop		ZL				
0001a8 91ff                      		pop		ZH
0001a9 91cf                      		pop		YL
0001aa 91df                      		pop		YH
0001ab 91af                      		pop		XL
0001ac 91bf                      		pop		XH
0001ad 902f                      		pop		zero
0001ae 900f                      		pop		rlo
0001af 901f                      		pop		rhi
0001b0 904f                      		pop		B
0001b1 903f                      		pop		A
0001b2 9508                      		ret						; End a function with RET
                                 
                                 ;***********************************************************
                                 ;*	Function: MUL5
                                 ;*  Describtion: cactulate operand5^2
                                 ;*	reference: lab5 MUL16 fucntion
                                 ;***********************************************************
                                 MUL5:
0001b3 923f                      		push 	A				; Save A register
0001b4 924f                      		push	B				; Save B register
0001b5 921f                      		push	rhi				; Save rhi register
0001b6 920f                      		push	rlo				; Save rlo register
0001b7 922f                      		push	zero			; Save zero register
0001b8 93bf                      		push	XH				; Save X-ptr
0001b9 93af                      		push	XL
0001ba 93df                      		push	YH				; Save Y-ptr
0001bb 93cf                      		push	YL				
0001bc 93ff                      		push	ZH				; Save Z-ptr
0001bd 93ef                      		push	ZL
0001be 931f                      		push	oloop			; Save counters
0001bf 932f                      		push	iloop				
                                 
0001c0 2422                      		clr		zero			; Maintain zero semantics
                                 
                                 		; Set Y to beginning address of B
0001c1 e0c8                      		ldi		YL, low(operand5)	; Load low byte
0001c2 e0d1                      		ldi		YH, high(operand5)	; Load high byte
                                 
                                 		; Set Z to begginning address of resulting Product
0001c3 e2e2                      		ldi		ZL, low(MUL_RESULT5)	; Load low byte
0001c4 e0f1                      		ldi		ZH, high(MUL_RESULT5); Load high byte
                                 
                                 		; Begin outer for loop
0001c5 e012                      		ldi		oloop, 2		; Load counter
                                 MUL5_OLOOP:
                                 		; Set X to beginning address of A
0001c6 e0a8                      		ldi		XL, low(operand5)	; Load low byte
0001c7 e0b1                      		ldi		XH, high(operand5)	; Load high byte
                                 
                                 		; Begin inner for loop
0001c8 e022                      		ldi		iloop, 2		; Load counter
                                 MUL5_ILOOP:
0001c9 903d                      		ld		A, X+			; Get byte of A operand
0001ca 8048                      		ld		B, Y			; Get byte of B operand
0001cb 9c34                      		mul		A,B				; Multiply A and B
0001cc 9031                      		ld		A, Z+			; Get a result byte from memory
0001cd 9041                      		ld		B, Z+			; Get the next result byte from memory
0001ce 0c03                      		add		rlo, A			; rlo <= rlo + A
0001cf 1c14                      		adc		rhi, B			; rhi <= rhi + B + carry
0001d0 8030                      		ld		A, Z			; Get a third byte from the result
0001d1 1c32                      		adc		A, zero			; Add carry to A
0001d2 8230                      		st		Z, A			; Store third byte to memory
0001d3 9212                      		st		-Z, rhi			; Store second byte to memory
0001d4 9202                      		st		-Z, rlo			; Store first byte to memory
0001d5 9631                      		adiw	ZH:ZL, 1		; Z <= Z + 1			
0001d6 952a                      		dec		iloop			; Decrement counter
0001d7 f789                      		brne	MUL5_ILOOP		; Loop if iLoop != 0
                                 		; End inner for loop
                                 
0001d8 9731                      		sbiw	ZH:ZL, 1		; Z <= Z - 1
0001d9 9621                      		adiw	YH:YL, 1		; Y <= Y + 1
0001da 951a                      		dec		oloop			; Decrement counter
0001db f751                      		brne	MUL5_OLOOP		; Loop if oLoop != 0
                                 		; End outer for loop
                                 		 		
0001dc 912f                      		pop		iloop			; Restore all registers in reverves order
0001dd 911f                      		pop		oloop
0001de 91ef                      		pop		ZL				
0001df 91ff                      		pop		ZH
0001e0 91cf                      		pop		YL
0001e1 91df                      		pop		YH
0001e2 91af                      		pop		XL
0001e3 91bf                      		pop		XH
0001e4 902f                      		pop		zero
0001e5 900f                      		pop		rlo
0001e6 901f                      		pop		rhi
0001e7 904f                      		pop		B
0001e8 903f                      		pop		A
0001e9 9508                      		ret						; End a function with RET
                                 
                                 
                                 ;***********************************************************
                                 ;*	Function: MUL6
                                 ;*  Describtion: cactulate operand6^2
                                 ;*	reference: lab5 MUL16 fucntion
                                 ;***********************************************************
                                 MUL6:
0001ea 923f                      		push 	A				; Save A register
0001eb 924f                      		push	B				; Save B register
0001ec 921f                      		push	rhi				; Save rhi register
0001ed 920f                      		push	rlo				; Save rlo register
0001ee 922f                      		push	zero			; Save zero register
0001ef 93bf                      		push	XH				; Save X-ptr
0001f0 93af                      		push	XL
0001f1 93df                      		push	YH				; Save Y-ptr
0001f2 93cf                      		push	YL				
0001f3 93ff                      		push	ZH				; Save Z-ptr
0001f4 93ef                      		push	ZL
0001f5 931f                      		push	oloop			; Save counters
0001f6 932f                      		push	iloop				
                                 
0001f7 2422                      		clr		zero			; Maintain zero semantics
                                 
                                 		; Set Y to beginning address of B
0001f8 e0ca                      		ldi		YL, low(operand6)	; Load low byte
0001f9 e0d1                      		ldi		YH, high(operand6)	; Load high byte
                                 
                                 		; Set Z to begginning address of resulting Product
0001fa e2e5                      		ldi		ZL, low(MUL_RESULT6)	; Load low byte
0001fb e0f1                      		ldi		ZH, high(MUL_RESULT6); Load high byte
                                 
                                 		; Begin outer for loop
0001fc e012                      		ldi		oloop, 2		; Load counter
                                 MUL6_OLOOP:
                                 		; Set X to beginning address of A
0001fd e0aa                      		ldi		XL, low(operand6)	; Load low byte
0001fe e0b1                      		ldi		XH, high(operand6)	; Load high byte
                                 
                                 		; Begin inner for loop
0001ff e022                      		ldi		iloop, 2		; Load counter
                                 MUL6_ILOOP:
000200 903d                      		ld		A, X+			; Get byte of A operand
000201 8048                      		ld		B, Y			; Get byte of B operand
000202 9c34                      		mul		A,B				; Multiply A and B
000203 9031                      		ld		A, Z+			; Get a result byte from memory
000204 9041                      		ld		B, Z+			; Get the next result byte from memory
000205 0c03                      		add		rlo, A			; rlo <= rlo + A
000206 1c14                      		adc		rhi, B			; rhi <= rhi + B + carry
000207 8030                      		ld		A, Z			; Get a third byte from the result
000208 1c32                      		adc		A, zero			; Add carry to A
000209 8230                      		st		Z, A			; Store third byte to memory
00020a 9212                      		st		-Z, rhi			; Store second byte to memory
00020b 9202                      		st		-Z, rlo			; Store first byte to memory
00020c 9631                      		adiw	ZH:ZL, 1		; Z <= Z + 1			
00020d 952a                      		dec		iloop			; Decrement counter
00020e f789                      		brne	MUL6_ILOOP		; Loop if iLoop != 0
                                 		; End inner for loop
                                 
00020f 9731                      		sbiw	ZH:ZL, 1		; Z <= Z - 1
000210 9621                      		adiw	YH:YL, 1		; Y <= Y + 1
000211 951a                      		dec		oloop			; Decrement counter
000212 f751                      		brne	MUL6_OLOOP		; Loop if oLoop != 0
                                 		; End outer for loop
                                 		 		
000213 912f                      		pop		iloop			; Restore all registers in reverves order
000214 911f                      		pop		oloop
000215 91ef                      		pop		ZL				
000216 91ff                      		pop		ZH
000217 91cf                      		pop		YL
000218 91df                      		pop		YH
000219 91af                      		pop		XL
00021a 91bf                      		pop		XH
00021b 902f                      		pop		zero
00021c 900f                      		pop		rlo
00021d 901f                      		pop		rhi
00021e 904f                      		pop		B
00021f 903f                      		pop		A
000220 9508                      		ret						; End a function with RET
                                 
                                 
                                 ;***********************************************************
                                 ;*	Function: ADD1
                                 ;*  Describtion: cactulate sqaure operand1 + square operand2
                                 ;*	reference: lab5 ADD16 fucntion
                                 ;***********************************************************
                                 ADD1:
                                 		; Load beginning address of first operand into X
000221 e1a6                      		ldi		XL, low(MUL_RESULT1)	; Load low byte of address
000222 e0b1                      		ldi		XH, high(MUL_RESULT1)	; Load high byte of address
                                 
                                 		; Load beginning address of second operand into Y
000223 e1c9                      		ldi		YL, low(MUL_RESULT2)	;load low byte of address
000224 e0d1                      		ldi		YH, high(MUL_RESULT2)	;load high byte of address
                                 
                                 		; Load beginning address of result into Z
000225 e0e0                      		ldi		ZL, low(Result1);load low byte of address
000226 e0fe                      		ldi		ZH, high(Result1);load high byte of address
                                 
                                 		; Execute the function
000227 903d                      		ld		A, X+	;load byte of first operand, post increment
000228 9049                      		ld		B, Y+	;load byte of second operand, post increment
000229 0c34                      		add		A, B	;add the two oprands together
00022a 9231                      		st		Z+, A	;store the sum into Z, post increment
00022b 903d                      		ld		A, X+	;load byte of first operand
00022c 9049                      		ld		B, Y+	;Load byte of second operand
00022d 1c34                      		adc		A, B	;add upper byte with carry
00022e 9231                      		st		Z+, A	;store the sum into Z, post increment
00022f 903d                      		ld		A, X+	;load byte of first operand
000230 9049                      		ld		B, Y+	;Load byte of second operand
000231 1c34                      		adc		A, B	;add upper byte with carry
000232 9231                      		st		Z+, A	;store the sum into Z, post increment
000233 2433                      		clr		A		;clear A
000234 1c32                      		adc		A, zero	;add A with carry bit
000235 8230                      		st		Z, A	;store result into Z  
000236 9508                      		ret						; End a function with RET
                                 
                                 
                                 ;***********************************************************
                                 ;*	Function: ADD2
                                 ;*  Describtion: cactulate sqaure operand3 + square operand4
                                 ;*	reference: lab5 ADD16 fucntion
                                 ;***********************************************************
                                 ADD2:
                                 		; Load beginning address of first operand into X
000237 e1ac                      		ldi		XL, low(MUL_RESULT3)	; Load low byte of address
000238 e0b1                      		ldi		XH, high(MUL_RESULT3)	; Load high byte of address
                                 
                                 		; Load beginning address of second operand into Y
000239 e1cf                      		ldi		YL, low(MUL_RESULT4)	;load low byte of address
00023a e0d1                      		ldi		YH, high(MUL_RESULT4)	;load high byte of address
                                 
                                 		; Load beginning address of result into Z
00023b e0e5                      		ldi		ZL, low(Result2);load low byte of address
00023c e0fe                      		ldi		ZH, high(Result2);load high byte of address
                                 
                                 		; Execute the function
00023d 903d                      		ld		A, X+	;load byte of first operand, post increment
00023e 9049                      		ld		B, Y+	;load byte of second operand, post increment
00023f 0c34                      		add		A, B	;add the two oprands together
000240 9231                      		st		Z+, A	;store the sum into Z, post increment
000241 903d                      		ld		A, X+	;load byte of first operand
000242 9049                      		ld		B, Y+	;Load byte of second operand
000243 1c34                      		adc		A, B	;add upper byte with carry
000244 9231                      		st		Z+, A	;store the sum into Z, post increment
000245 903d                      		ld		A, X+	;load byte of first operand
000246 9049                      		ld		B, Y+	;Load byte of second operand
000247 1c34                      		adc		A, B	;add upper byte with carry
000248 9231                      		st		Z+, A	;store the sum into Z, post increment
000249 2433                      		clr		A		;clear A
00024a 1c32                      		adc		A, zero	;add A with carry bit
00024b 8230                      		st		Z, A	;store result into Z  
00024c 9508                      		ret						; End a function with RET
                                 
                                 
                                 ;***********************************************************
                                 ;*	Function: ADD3
                                 ;*  Describtion: cactulate sqaure operand5 + square operand6
                                 ;*	reference: lab5 ADD16 fucntion
                                 ;***********************************************************
                                 ADD3:
                                 		; Load beginning address of first operand into X
00024d e2a2                      		ldi		XL, low(MUL_RESULT5)	; Load low byte of address
00024e e0b1                      		ldi		XH, high(MUL_RESULT5)	; Load high byte of address
                                 
                                 		; Load beginning address of second operand into Y
00024f e2c5                      		ldi		YL, low(MUL_RESULT6)	;load low byte of address
000250 e0d1                      		ldi		YH, high(MUL_RESULT6)	;load high byte of address
                                 
                                 		; Load beginning address of result into Z
000251 e0ea                      		ldi		ZL, low(Result3);load low byte of address
000252 e0fe                      		ldi		ZH, high(Result3);load high byte of address
                                 
                                 		; Execute the function
000253 903d                      		ld		A, X+	;load byte of first operand, post increment
000254 9049                      		ld		B, Y+	;load byte of second operand, post increment
000255 0c34                      		add		A, B	;add the two oprands together
000256 9231                      		st		Z+, A	;store the sum into Z, post increment
000257 903d                      		ld		A, X+	;load byte of first operand
000258 9049                      		ld		B, Y+	;Load byte of second operand
000259 1c34                      		adc		A, B	;add upper byte with carry
00025a 9231                      		st		Z+, A	;store the sum into Z, post increment
00025b 903d                      		ld		A, X+	;load byte of first operand
00025c 9049                      		ld		B, Y+	;Load byte of second operand
00025d 1c34                      		adc		A, B	;add upper byte with carry
00025e 9231                      		st		Z+, A	;store the sum into Z, post increment
00025f 2433                      		clr		A		;clear A
000260 1c32                      		adc		A, zero	;add A with carry bit
000261 8230                      		st		Z, A	;store result into Z  
000262 9508                      		ret						; End a function with RET
                                 
                                 ;***********************************************************
                                 ;*	Function: ROOT1
                                 ;*  Describtion: cactulate sqaure root  result x^2+y^2
                                 ;***********************************************************
                                 ROOT1:
000263 e0c0                      	ldi YL, low(Result1)		;low byte of Result x^2+y^2
000264 e0de                      	ldi YH, high(Result1)		;high byte of Result x^2+y^2
000265 e0e0                      	ldi ZL, low (Result1)		;low byte of root  
000266 e0fe                      	ldi ZH, high(Result1)		;high byte of root
                                 
000267 9039                      	ld A, Y+					;load low byte of result x^2+y^2
000268 9049                      	ld B, Y+					;load low byte of result x^2+y^2
000269 8058                      	ld C, Y						;load high byte of result x^2+y^2
00026a e050                      	ldi best, 0					
00026b e081                      	ldi counter_low, 1			;load 1 to counter low
00026c e090                      	ldi counter_high, 0			;load 0 to counter high
00026d e060                      	ldi root_low, 0				;load 0 to root low
00026e e070                      	ldi root_high, 0			;load 0 to root low 
                                 
                                 
                                 ROOT_LOOP1:
00026f 1a38                      	sub A, counter_low				;sub A 
000270 0a45                      	sbc B, best						;Subtract with Carry
000271 0a55                      	sbc C, best						;Subtract with Carry
000272 f130                      	brcs ROOT_GET_G1				;if A < counter_low
000273 f0f9                      	breq ROOT_GET1					; if A =  counter_low
000274 3f8f                      	cpi counter_low, 255			;compare conter_low and 255
000275 f039                      	breq ROOT_LOW1					;if counter_low,255
000276 9583                      	inc counter_low					;counter_low incresement
000277 9583                      	inc counter_low					;counter_low incresement
000278 9563                      	inc root_low					;root_low incresement
000279 cff5                      	rjmp ROOT_LOOP1					;re loop
                                 
                                 ROOT_HIGH1:
00027a 9573                      	inc root_high					;high byte root increse
00027b 2766                      	clr root_low					;clear low byte root 
00027c c009                      	rjmp ROOT_LOOP_LOOP1					;re loop
                                 	
                                 ROOT_LOW1:
00027d 9593                      	inc counter_high				;counter_high byte ;	
00027e 2788                      	clr counter_low					;clear counter low byte
00027f 9583                      	inc counter_low					;re start sub 
000280 1a38                      	sub A, counter_low				;sub A and counter_low
000281 0a49                      	sbc B, counter_high				; high byte sub
000282 0a55                      	sbc C, best						;Subtract with Carry
000283 9563                      	inc root_low
000284 3f6f                      	cpi root_low, 255				;compare conter_low and 255
000285 f3a1                      	breq ROOT_HIGH1					;if root_low,255
                                 
                                 ROOT_LOOP_LOOP1:
000286 3f8f                      	cpi counter_low, 255			;compare conter_low and 255
000287 f3a9                      	breq ROOT_LOW1					;if counter_low,255
000288 9583                      	inc counter_low					;counter_low incresement
000289 9583                      	inc counter_low					;counter_low incresement
00028a 1a38                      	sub A, counter_low				;sub A and counter_low
00028b 0a49                      	sbc B, counter_high				; high byte sub
00028c 0a55                      	sbc C, best						;Subtract with Carry
00028d f028                      	brcs ROOT_GET1					;if A < counter_low
00028e f051                      	breq ROOT_GET_G1				; if A =  counter_low
00028f 9563                      	inc root_low
000290 3f6f                      	cpi root_low, 255				;compare conter_low and 255
000291 f341                      	breq ROOT_HIGH1					;if root_low,255
000292 cff3                      	rjmp ROOT_LOOP_LOOP1
                                 
                                 ROOT_GET1:
000293 9105                      	lpm mpr, Z+						;load memory program by Z+
000294 9105                      	lpm mpr, Z+						;load memory program by Z+
000295 9105                      	lpm mpr, Z+						;load memory program by Z+
000296 9361                      	st Z+, root_low					;store root_low to Z+
000297 8370                      	st Z, root_high					;store root_high to Z	
000298 9508                      	ret								; End a function with RET
                                 
                                 ROOT_GET_G1:
000299 9105                      	lpm mpr, Z+						;load memory program by Z+
00029a 9105                      	lpm mpr, Z+						;load memory program by Z+
00029b 9105                      	lpm mpr, Z+						;load memory program by Z+
00029c 9563                      	inc root_low
00029d 9361                      	st Z+, root_low					;store root_low to Z+
00029e 8370                      	st Z, root_high					;store root_high to Z
00029f 9508                      	ret								; End a function with RET
                                 
                                 ;***********************************************************
                                 ;*	Function: ROOT2
                                 ;*  Describtion: cactulate sqaure root  result x^2+y^2
                                 ;***********************************************************
                                 ROOT2:
0002a0 e0c5                      	ldi YL, low(Result2)		;low byte of Result x^2+y^2
0002a1 e0de                      	ldi YH, high(Result2)		;high byte of Result x^2+y^2
0002a2 e0e5                      	ldi ZL, low (Result2)		;low byte of root  
0002a3 e0fe                      	ldi ZH, high(Result2)		;high byte of root
                                 
0002a4 9039                      	ld A, Y+					;load low byte of result x^2+y^2
0002a5 9049                      	ld B, Y+					;load low byte of result x^2+y^2
0002a6 8058                      	ld C, Y						;load high byte of result x^2+y^2
0002a7 e050                      	ldi best, 0					
0002a8 e081                      	ldi counter_low, 1			;load 1 to counter low
0002a9 e090                      	ldi counter_high, 0			;load 0 to counter high
0002aa e060                      	ldi root_low, 0				;load 0 to root low
0002ab e070                      	ldi root_high, 0			;load 0 to root low 
                                 
                                 
                                 ROOT_LOOP2:
0002ac 1a38                      	sub A, counter_low				;sub A 
0002ad 0a45                      	sbc B, best						;Subtract with Carry
0002ae 0a55                      	sbc C, best						;Subtract with Carry
0002af f130                      	brcs ROOT_GET_G2					;if A < counter_low
0002b0 f0f9                      	breq ROOT_GET2					; if A =  counter_low
0002b1 3f8f                      	cpi counter_low, 255			;compare conter_low and 255
0002b2 f039                      	breq ROOT_LOW2					;if counter_low,255
0002b3 9583                      	inc counter_low					;counter_low incresement
0002b4 9583                      	inc counter_low					;counter_low incresement
0002b5 9563                      	inc root_low					;root_low incresement
0002b6 cff5                      	rjmp ROOT_LOOP2					;re loop
                                 ROOT_HIGH2:
0002b7 9573                      	inc root_high					;high byte root increse
0002b8 2766                      	clr root_low					;clear low byte root 
0002b9 c009                      	rjmp ROOT_LOOP_LOOP2					;re loop
                                 	
                                 ROOT_LOW2:
0002ba 9593                      	inc counter_high				;counter_high byte ;	
0002bb 2788                      	clr counter_low					;clear counter low byte
0002bc 9583                      	inc counter_low					;re start sub 
0002bd 1a38                      	sub A, counter_low				;sub A and counter_low
0002be 0a49                      	sbc B, counter_high				; high byte sub
0002bf 0a55                      	sbc C, best						;Subtract with Carry
0002c0 9563                      	inc root_low
0002c1 3f6f                      	cpi root_low, 255				;compare conter_low and 255
0002c2 f3a1                      	breq ROOT_HIGH2					;if root_low,255
                                 
                                 ROOT_LOOP_LOOP2:
0002c3 3f8f                      	cpi counter_low, 255			;compare conter_low and 255
0002c4 f3a9                      	breq ROOT_LOW2					;if counter_low,255
0002c5 9583                      	inc counter_low					;counter_low incresement
0002c6 9583                      	inc counter_low					;counter_low incresement
0002c7 1a38                      	sub A, counter_low				;sub A and counter_low
0002c8 0a49                      	sbc B, counter_high				; high byte sub
0002c9 0a55                      	sbc C, best						;Subtract with Carry
0002ca f028                      	brcs ROOT_GET2					;if A < counter_low
0002cb f051                      	breq ROOT_GET_G2					; if A =  counter_low
0002cc 9563                      	inc root_low
0002cd 3f6f                      	cpi root_low, 255				;compare conter_low and 255
0002ce f341                      	breq ROOT_HIGH2					;if root_low,255
0002cf cff3                      	rjmp ROOT_LOOP_LOOP2
                                 
                                 ROOT_GET2:
0002d0 9105                      	lpm mpr, Z+						;load memory program by Z+
0002d1 9105                      	lpm mpr, Z+						;load memory program by Z+
0002d2 9105                      	lpm mpr, Z+						;load memory program by Z+
0002d3 9361                      	st Z+, root_low					;store root_low to Z+
0002d4 8370                      	st Z, root_high					;store root_high to Z	
0002d5 9508                      	ret								; End a function with RET
                                 
                                 ROOT_GET_G2:
0002d6 9105                      	lpm mpr, Z+						;load memory program by Z+
0002d7 9105                      	lpm mpr, Z+						;load memory program by Z+
0002d8 9105                      	lpm mpr, Z+						;load memory program by Z+
0002d9 9563                      	inc root_low
0002da 9361                      	st Z+, root_low					;store root_low to Z+
0002db 8370                      	st Z, root_high					;store root_high to Z
0002dc 9508                      	ret								; End a function with RET	
                                 
                                 ;***********************************************************
                                 ;*	Function: ROOT3
                                 ;*  Describtion: cactulate sqaure root  result x^2+y^2
                                 ;***********************************************************
                                 ROOT3:
0002dd e0ca                      	ldi YL, low(Result3)		;low byte of Result x^2+y^2
0002de e0de                      	ldi YH, high(Result3)		;high byte of Result x^2+y^2
0002df e0ea                      	ldi ZL, low (Result3)		;low byte of root  
0002e0 e0fe                      	ldi ZH, high(Result3)		;high byte of root
                                 
0002e1 9039                      	ld A, Y+					;load low byte of result x^2+y^2
0002e2 9049                      	ld B, Y+					;load low byte of result x^2+y^2
0002e3 8058                      	ld C, Y						;load high byte of result x^2+y^2
0002e4 e050                      	ldi best, 0					
0002e5 e081                      	ldi counter_low, 1			;load 1 to counter low
0002e6 e090                      	ldi counter_high, 0			;load 0 to counter high
0002e7 e060                      	ldi root_low, 0				;load 0 to root low
0002e8 e070                      	ldi root_high, 0			;load 0 to root low 
                                 
                                 
                                 ROOT_LOOP3:
0002e9 1a38                      	sub A, counter_low				;sub A 
0002ea 0a45                      	sbc B, best						;Subtract with Carry
0002eb 0a55                      	sbc C, best						;Subtract with Carry
0002ec f130                      	brcs ROOT_GET_G3				;if A < counter_low
0002ed f0f9                      	breq ROOT_GET3					; if A =  counter_low
0002ee 3f8f                      	cpi counter_low, 255			;compare conter_low and 255
0002ef f039                      	breq ROOT_LOW3					;if counter_low,255
0002f0 9583                      	inc counter_low					;counter_low incresement
0002f1 9583                      	inc counter_low					;counter_low incresement
0002f2 9563                      	inc root_low					;root_low incresement
0002f3 cff5                      	rjmp ROOT_LOOP3					;re loop
                                 ROOT_HIGH3:
0002f4 9573                      	inc root_high					;high byte root increse
0002f5 2766                      	clr root_low					;clear low byte root 
0002f6 c009                      	rjmp ROOT_LOOP_LOOP3					;re loop
                                 	
                                 ROOT_LOW3:
0002f7 9593                      	inc counter_high				;counter_high byte ;	
0002f8 2788                      	clr counter_low					;clear counter low byte
0002f9 9583                      	inc counter_low					;re start sub 
0002fa 1a38                      	sub A, counter_low				;sub A and counter_low
0002fb 0a49                      	sbc B, counter_high				; high byte sub
0002fc 0a55                      	sbc C, best						;Subtract with Carry
0002fd 9563                      	inc root_low
0002fe 3f6f                      	cpi root_low, 255				;compare conter_low and 255
0002ff f3a1                      	breq ROOT_HIGH3					;if root_low,255
                                 
                                 ROOT_LOOP_LOOP3:
000300 3f8f                      	cpi counter_low, 255			;compare conter_low and 255
000301 f3a9                      	breq ROOT_LOW3					;if counter_low,255
000302 9583                      	inc counter_low					;counter_low incresement
000303 9583                      	inc counter_low					;counter_low incresement
000304 1a38                      	sub A, counter_low				;sub A and counter_low
000305 0a49                      	sbc B, counter_high				; high byte sub
000306 0a55                      	sbc C, best						;Subtract with Carry
000307 f028                      	brcs ROOT_GET3					;if A < counter_low
000308 f051                      	breq ROOT_GET_G3				; if A =  counter_low
000309 9563                      	inc root_low
00030a 3f6f                      	cpi root_low, 255				;compare conter_low and 255
00030b f341                      	breq ROOT_HIGH3					;if root_low,255
00030c cff3                      	rjmp ROOT_LOOP_LOOP3
                                 
                                 ROOT_GET3:
00030d 9105                      	lpm mpr, Z+						;load memory program by Z+
00030e 9105                      	lpm mpr, Z+						;load memory program by Z+
00030f 9105                      	lpm mpr, Z+						;load memory program by Z+
000310 9361                      	st Z+, root_low					;store root_low to Z+
000311 8370                      	st Z, root_high					;store root_high to Z	
000312 9508                      	ret								; End a function with RET
                                 
                                 ROOT_GET_G3:
000313 9105                      	lpm mpr, Z+						;load memory program by Z+
000314 9105                      	lpm mpr, Z+						;load memory program by Z+
000315 9105                      	lpm mpr, Z+						;load memory program by Z+
000316 9563                      	inc root_low
000317 9361                      	st Z+, root_low					;store root_low to Z+
000318 8370                      	st Z, root_high					;store root_high to Z
000319 9508                      	ret								; End a function with RET
                                 
                                 ;******************************************************************
                                 ;*	Function: CHOICE
                                 ;*  Describtion: Find the closerest distance
                                 ;******************************************************************
                                 CHOICE:
00031a e0a0                      		ldi XL, low(Result1)	;low byte of Result1
00031b e0be                      		ldi XH, high(Result1)	;high byte of Result1
00031c e0c5                      		ldi YL, low	(Result2)	;low byte of Result2
00031d e0de                      		ldi YH, high(Result2)	;high byte of Result2
00031e e0ea                      		ldi ZL, low (Result3)	;low byte of Result3
00031f e0fe                      		ldi ZH, high(Result3)	;high byte of Result3
                                 
000320 903d                      		ld A, X+		;move byte
000321 903d                      		ld A, X+		;move byte
000322 903d                      		ld A, X+		;move byte
000323 903d                      		ld A, X+		;get low btye of Result1
000324 904c                      		ld B, X			;get high byte of Result1
000325 9059                      		ld C, Y+		;move byte 
000326 9059                      		ld C, Y+		;move byte
000327 9059                      		ld C, Y+		;move byte
000328 9059                      		ld C, Y+		;get low btye of Result2
000329 8068                      		ld D, Y			;get high byte of Result2
00032a 9071                      		ld E, Z+		;move byte
00032b 9071                      		ld E, Z+		;move byte
00032c 9071                      		ld E, Z+		;move byte
00032d 9071                      		ld E, Z+		;get low btye of Result3
00032e 8080                      		ld F, Z			; get high byte of Result3			
00032f e050                      		ldi best, 0
                                 
                                 COMPARE_BD:
000330 1446                      		cp	B,D					;compare high byte
000331 f030                      		brcs COMPARE_BF		    ;B<D picke BA and cp EF
000332 f009                      		breq CPMARE_LOW_AC		;B=D TO  CP A C
000333 c00c                      		rjmp COMPARE_DF			;B>D Pick D
                                 
                                 CPMARE_LOW_AC:
000334 1435                      		cp A, C					;compare low byte
000335 f010                      		brcs COMPARE_BF			;A<C compare bf
000336 f009                      		breq COMPARE_BF			;A=C continue cp thrid point
000337 c008                      		rjmp COMPARE_DF			;A>C compare df
                                 
                                 COMPARE_BF:
000338 1448                      		cp B,F ;compare high byte BF
000339 f070                      		brcs CHOICE_AB		;B<F  TO pick AB
00033a f009                      		breq COMPARE_LOW_AE	;B=F TO cp AE
00033b c017                      		rjmp CHOICE_EF		;B>F to pick EF	
                                 
                                 COMPARE_LOW_AE:
00033c 1437                      		cp A, E ;cpmpare low byte A E
00033d f050                      		brcs CHOICE_AB			;A<E pick AB
00033e f0d1                      		breq COMPARE_SAME		; A=E  is same
00033f c013                      		rjmp CHOICE_EF			; A>E PICK EF
                                 
                                 COMPARE_DF:
000340 1468                      		cp D, F			;COMPARE HIGH BYTE D F
000341 f058                      		brcs CHOICE_CD			;D<F pick cd
000342 f009                      		breq COMPARE_LOW_CE		; D=F cp low byte
000343 c00f                      		rjmp CHOICE_EF			; D>F pick EF
                                 
                                 COMPARE_LOW_CE:
000344 1457                      		cp C, E			;compare low byte ce
000345 f038                      		brcs CHOICE_CD			;C<E pick cd
000346 f091                      		breq COMPARE_SAME		;C=E
000347 c00b                      		rjmp CHOICE_EF			;C>F pick ef
                                 
                                 CHOICE_AB:
000348 e0af                      	ldi	XL,low (BestChoice)		;loade low byte
000349 e0be                      	ldi XH, high(BestChoice)	;loade high byte
00034a e051                      	ldi best, 1					;lode value
00034b 935d                      	st X+, best
00034c 9508                      	ret
                                 
                                 CHOICE_CD:
00034d e0cf                      	ldi	YL,low (BestChoice)		;loade low byte
00034e e0de                      	ldi YH, high(BestChoice)	;loade high byte
00034f 9159                      	ld best, Y+					;load byte
000350 e052                      	ldi best, 2					;lode value
000351 9359                      	st Y+, best					;store value
000352 9508                      	ret							;end 
                                 
                                 CHOICE_EF:
000353 e0ef                      	ldi	ZL,low (BestChoice)		;loade low byte
000354 e0fe                      	ldi ZH, high(BestChoice)	;loade high byte
000355 9151                      	ld best, Z+					;load byte
000356 e053                      	ldi best, 3					;lode value
000357 9351                      	st Z+, best					;store value
000358 9508                      	ret							;end
                                 COMPARE_SAME:
000359 e0af                      	ldi	XL,low (BestChoice)		;loade low byte
00035a e0be                      	ldi XH, high(BestChoice)	;loade high byte
00035b 915d                      	ld best, X+					;load byte
00035c ef5f                      	ldi best, -1				;store value
00035d 935d                      	st X+, best					;store value
00035e 9508                      	ret							;end
                                 
                                 
                                 ;******************************************************************
                                 ;*	Function: Distance
                                 ;*  Describtion: cactulate the average distance of Three distance
                                 ;******************************************************************
                                 DISTANCE:
                                 		;get tatal distance
00035f d019                      		rcall ADD_Distance1 
000360 d030                      		rcall ADD_Distance2
                                 
000361 e2cf                      		ldi	YL, low(ADD_RESULT2)	;load low byte of address
000362 e0d1                      		ldi YH, high(ADD_RESULT2)	;load high byte of address
                                 
000363 e1e0                      		ldi ZL, low(AvgDistance)	;load low byte of address
000364 e0fe                      		ldi ZH, high(AvgDistance)	;load high byte of address
                                 
000365 9039                      		ld	A, Y+	;load low byte 
000366 8048                      		ld	B, Y		;load high byte
000367 e050                      		ldi best, 0					
000368 e083                      		ldi counter_low, 3			;load 1 to counter low
000369 e060                      		ldi root_low, 0				;load 0 to root low
00036a e070                      		ldi root_high, 0			;load 0 to root low 
                                 
                                 DISTANCE_LOOP:
00036b 1a38                      	sub A, counter_low				;sub A 
00036c 0a45                      	sbc B, best						;Subtract with Carry
00036d f040                      	brcs DIS_LOOP1					;if A < counter_low
00036e f039                      	breq DIS_LOOP1					; if A =  counter_low
00036f 9563                      	inc  root_low					;increse root_low
000370 3f6f                      	cpi root_low, 255				;compare conter_low and 255
000371 f009                      	breq DIS_HIGH					;if counter_low,255
000372 cff8                      	rjmp DISTANCE_LOOP				;re loop
                                 
                                 DIS_HIGH:
000373 9573                      	inc root_high					;high byte root increse
000374 2766                      	clr root_low					;clear low byte root 
000375 cff5                      	rjmp DISTANCE_LOOP					;re loop
                                 
                                 DIS_LOOP1:
000376 9361                      	st Z+, root_low					;store root_low to Z+
000377 8370                      	st Z, root_high					;store root_high to Z
000378 9508                      	ret								; End a function with RET
                                 
                                 	
                                 ;******************************************************************
                                 ;*	Function: ADD_Distance1
                                 ;*  Describtion: cactulate add result1 distance + result2 distance
                                 ;******************************************************************
                                 ADD_Distance1:
000379 e0a0                      		ldi		XL, low(Result1)	; Load low byte of address
00037a e0be                      		ldi		XH, high(Result1)	; Load high byte of address
                                 
                                 		; Load beginning address of second operand into Y
00037b e0c5                      		ldi		YL, low(Result2)	;load low byte of address
00037c e0de                      		ldi		YH, high(Result2)	;load high byte of address
                                 
                                 		; Load beginning address of result into Z
00037d e2ec                      		ldi		ZL, low(ADD_RESULT1);load low byte of address
00037e e0f1                      		ldi		ZH, high(ADD_RESULT1);load high byte of address
                                 
                                 		; Execute the function
00037f 903d                      		ld		A, X+	;load first byte of first operand, post increment	
000380 903d                      		ld		A, X+	;load first byte of first operand, post increment
000381 903d                      		ld		A, X+	;load first byte of first operand, post increment
000382 903d                      		ld		A, X+	;load first byte of first operand, post increment
000383 9049                      		ld		B, Y+	;load first byte of second operand, post increment
000384 9049                      		ld		B, Y+	;load first byte of second operand, post increment
000385 9049                      		ld		B, Y+	;load first byte of second operand, post increment
000386 9049                      		ld		B, Y+	;load first byte of second operand, post increment
000387 0c34                      		add		A, B	;add the two oprands together
000388 9231                      		st		Z+, A	;store the sum into Z, post increment
000389 903c                      		ld		A, X	;load second byte of first operand
00038a 8048                      		ld		B, Y	;Load second byte of second operand
00038b 1c34                      		adc		A, B	;add upper byte with carry
00038c 9231                      		st		Z+, A	;store the sum into Z, post increment
00038d 2433                      		clr		A		;clear A
00038e 1c32                      		adc		A, zero	;add A with carry bit
00038f 8230                      		st		Z, A	;store result into Z  
                                 
                                 		
000390 9508                      		ret						; End a function with RET
                                 
                                 ;******************************************************************
                                 ;*	Function: ADD_Distance2
                                 ;*  Describtion: cactulate add result1 distance + result2 distance
                                 ;******************************************************************
                                 ADD_Distance2:
000391 e2ac                      		ldi		XL, low(ADD_RESULT1)	; Load low byte of address
000392 e0b1                      		ldi		XH, high(ADD_RESULT1)	; Load high byte of address
                                 
                                 		; Load beginning address of second operand into Y
000393 e0ca                      		ldi		YL, low(Result3)	;load low byte of address
000394 e0de                      		ldi		YH, high(Result3)	;load high byte of address
                                 
                                 		; Load beginning address of result into Z
000395 e2ef                      		ldi		ZL, low(ADD_RESULT2);load low byte of address
000396 e0f1                      		ldi		ZH, high(ADD_RESULT2);load high byte of address
                                 
                                 		; Execute the function
000397 903d                      		ld		A, X+	;load first byte of first operand, post increment
000398 9049                      		ld		B, Y+	;load first byte of second operand, post increment
000399 9049                      		ld		B, Y+	;load first byte of second operand, post increment
00039a 9049                      		ld		B, Y+	;load first byte of second operand, post increment
00039b 9049                      		ld		B, Y+	;load first byte of second operand, post increment
00039c 0c34                      		add		A, B	;add the two oprands together
00039d 9231                      		st		Z+, A	;store the sum into Z, post increment
00039e 903c                      		ld		A, X	;load second byte of first operand
00039f 8048                      		ld		B, Y	;Load second byte of second operand
0003a0 1c34                      		adc		A, B	;add upper byte with carry
0003a1 9231                      		st		Z+, A	;store the sum into Z, post increment
0003a2 2433                      		clr		A		;clear A
0003a3 1c32                      		adc		A, zero	;add A with carry bit
0003a4 8230                      		st		Z, A	;store result into Z  
                                 
                                 		
0003a5 9508                      		ret						; End a function with RET
                                 
                                 
                                 ;***end of your code***end of your code***end of your code***end of your code***end of your code***
                                 ;******************************* Do not change below this point************************************
                                 ;******************************* Do not change below this point************************************
                                 ;******************************* Do not change below this point************************************
                                 
                                 Grading:
0003a6 0000                      		nop					; Check the results and number of cycles (The TA will set a breakpoint here)
0003a7 cffe                      rjmp Grading
                                 
                                 
                                 ;***********************************************************
                                 ;*	Stored Program Data
                                 ;***********************************************************
                                 
                                 ; Contents of program memory will be changed during testing
                                 ; The label names (Treasures, UserLocation) are not changed
                                 ; See the lab instructions for an explanation of TreasureInfo. The 10 bit values are packed together.
                                 ; In this example, the three treasures are located at (5, 25), (35, -512), and (0, 511)
0003a8 4101
0003a9 8e90
0003aa 0000
0003ab f01f                      TreasureInfo:	.DB	0x01, 0x41, 0x90, 0x8E, 0x00, 0x00, 0x1F, 0xF0		
                                 ;UserLocation:	.DB 0x00, 0x00, 0x00 	; this is only used for the challenge code
                                 
                                 ;***********************************************************
                                 ;*	Data Memory Allocation for Results
                                 ;***********************************************************
                                 .dseg
                                 .org	$0E00						; data memory allocation for results - Your grader only checks $0E00 - $0E11
000e00                           Result1:		.byte 5				; x2_plus_y2, square_root (for treasure 1)
000e05                           Result2:		.byte 5				; x2_plus_y2, square_root (for treasure 2)
000e0a                           Result3:		.byte 5				; x2_plus_y2, square_root (for treasure 3)
000e0f                           BestChoice:		.byte 1				; which treasure is closest? (indicate this with a value of 1, 2, or 3)
                                 									; this should have a value of -1 in the special case when the 3 treasures
                                 									; have an equal (rounded) distance
000e10                           AvgDistance:	.byte 2				; the average distance to a treasure chest (rounded upward if the value was not already an integer)
                                 
                                 ;***********************************************************
                                 ;*	Additional Program Includes
                                 ;***********************************************************
                                 ; There are no additional file includes for this program


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :  30 y  :  54 z  : 105 r0 :  24 r1 :  24 r2 :  44 r3 : 131 r4 :  85 
r5 :  18 r6 :   3 r7 :   6 r8 :   3 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16:  59 r17:  24 r18:  24 r19:   0 r20:  29 
r21:  73 r22:  35 r23:  15 r24:  38 r25:  12 r26:  26 r27:  26 r28:  41 
r29:  41 r30:  42 r31:  42 
Registers used: 27 out of 35 (77.1%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  25 add   :  11 adiw  :  12 and   :   0 
andi  :   0 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :  13 break :   0 breq  :  26 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  12 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :  20 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   6 cpc   :   0 
cpi   :  13 cpse  :   0 dec   :  12 elpm  :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :   0 inc   :  35 
jmp   :   1 ld    :  94 ldd   :   0 ldi   : 148 lds   :   0 lpm   :  35 
lsl   :  24 lsr   :   0 mov   :  14 movw  :   0 mul   :   6 muls  :   0 
mulsu :   0 neg   :   0 nop   :   1 or    :   0 ori   :   0 out   :   2 
pop   :  78 push  :  78 rcall :  16 ret   :  22 reti  :   0 rjmp  :  19 
rol   :  48 ror   :   0 sbc   :  19 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   6 sbr   :   0 sbrc  :   0 sbrs  :   0 sec   :   0 
seh   :   0 sei   :   0 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :  65 std   :   0 
sts   :   0 sub   :  10 subi  :   0 swap  :   0 tst   :   0 wdr   :   0 

Instructions used: 30 out of 114 (26.3%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000758   1734      8   1742  131072   1.3%
[.dseg] 0x000100 0x000e12      0     63     63    4096   1.5%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
